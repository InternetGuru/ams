#!/bin/bash

## functions
gitlab_api() {
  declare -r url="${1}"
  declare data="${2}"
  declare req='GET'
  [[ -n "${data}" ]] \
    && req='POST'
  [[ "${data}" == '-' ]] \
    && req='DELETE' \
    && data="{}"
  # shellcheck disable=SC2155
  declare response="$(curl --silent --write-out '\n%{http_code}\n' \
    --header "Authorization: Bearer ${TOKEN}" \
    --header 'Content-Type: application/json' \
    --request ${req} --data "${data:-{\}}" "https://${GITLAB_URL}/${url}")"
  # shellcheck disable=SC2155
  declare status="$(sed -n '$p' <<< "${response}")"
  # shellcheck disable=SC2155
  declare output="$(sed '$d' <<< "${response}")"
  [[ "${status}" != 20* ]] \
    && printf -- '%s\n' "${output}" >&2 \
    && exception "Request status ${status}: ${url}"
  printf -- '%s\n' "${output}"
}
authorize() {
  [[ "$(tty)" =~ "not a tty" ]] \
    && exception "Unable to authorize without TOKEN_FILE"
  exec 0</dev/tty
  prompt 'Username'
  declare username="${REPLY}"
  prompt 'Password' silent
  declare password="${REPLY}"
  echo
  gitlab_api 'oauth/token' \
    "{\"grant_type\":\"password\", \"username\":\"${username}\", \"password\":\"${password}\"}" \
    | jq -r '.access_token' > "${TOKEN_FILE}"
}
get_project_id() {
  declare -r project_name="${1//\//%2F}"
  gitlab_api "api/v4/projects/${project_name}" | jq -r '.id'
}
get_default_branch() {
  declare -r project_name="${1//\//%2F}"
  gitlab_api "api/v4/projects/$project_name" | jq -r '.default_branch'
}
project_exists() {
  declare -r project_name="${1}"
  get_project_id "${project_name}" >/dev/null 2>&1
}
get_group_id() {
  declare -r group_name="${1//\//%2F}"
  gitlab_api "api/v4/groups/${group_name}" | jq -r '.id'
}
request_exists() {
  declare -r project_id="${1}"
  gitlab_api "api/v4/projects/${project_id}/merge_requests?state=opened&source_branch=${SOURCE_BRANCH}" \
    | grep -qv "^\[\]$"
}
create_request() {
  declare -r project_id="${1}"
  declare -r target_branch="${2}"
  gitlab_api "api/v4/projects/${project_id}/merge_requests" \
    "{\"id\":\"${project_id}\", \"source_branch\":\"${SOURCE_BRANCH}\", \"target_branch\":\"${target_branch}\", \
    \"remove_source_branch\":\"false\", \"title\":\"Update from ${SOURCE_BRANCH} branch\"}" >/dev/null
}
create_project() {
  declare -r group_id="${1}"
  declare -r project_name="${2}"
  declare -r user_id="${3}"
  declare visibility='public'
  [[ -n "${user_id}" ]] \
    && visibility='private'
  gitlab_api 'api/v4/projects' \
    "{\"namespace_id\":\"${group_id}\", \"name\":\"${project_name}\", \"visibility\":\"${visibility}\"}" \
    | jq -r '.id'
}
get_role() {
  declare -r project_id="${1}"
  declare -r user_id="${2}"
  gitlab_api "api/v4/projects/${project_id}/members/all/${user_id}" | jq -r '.access_level'
}
add_developer() {
  declare -r project_id="${1}"
  declare -r user_id="${2}"
  [[ -z "${user_id}" ]] \
    && return
  # shellcheck disable=SC2155
  declare -ir role="$(get_role "${project_id}" "${user_id}" 2>/dev/null)"
  (( role >= DEV_ACCESS_LEVEL )) \
    && return
  gitlab_api "api/v4/projects/${project_id}/members" \
    "{\"access_level\":\"${DEV_ACCESS_LEVEL}\", \"user_id\":\"${user_id}\"}" >/dev/null
}
remove_protected_branch() {
  declare -r project_id="${1}"
  declare -r branch="${2}"
  gitlab_api "api/v4/projects/${project_id}/protected_branches/${branch}" '-' >/dev/null
}
set_protected_branch() {
  declare -r project_id="${1}"
  declare -r branch="${2}"
  declare -r access_level="${3}"
  gitlab_api "api/v4/projects/${project_id}/protected_branches?name=${branch}&push_access_level=${access_level}&merge_access_level=${access_level}" '{}' >/dev/null
}
create_group() {
  declare -r group_name="${1}"
  declare -r parent_id="${2}"
  gitlab_api 'api/v4/groups' \
    "{\"name\":\"${group_name}\", \"path\":\"${group_name}\", \"parent_id\":\"${parent_id}\", \"visibility\":\"public\"}" \
    | jq -r '.id'
}
get_user_id() {
  declare -r user="${1}"
  gitlab_api "api/v4/users?username=${user}" \
    | jq -r '.[] | .id' | sed 's/null//'
}
create_ns() {
  declare -r ns="${1}"
  # shellcheck disable=SC2155
  declare -r parent_ns="$(dirname "${1}")"
  [[ "${parent_ns}" == '.' ]] \
    && exception "Root group ${ns} does not exist"
  declare parent_id
  parent_id="$(get_group_id "${parent_ns}" 2>/dev/null)" \
    || parent_id="$(create_ns "${parent_ns}")" \
    || exit 1
  create_group "$(basename "${ns}")" "${parent_id}"
}
get_remote_namespace() {
  declare -r cache_folder="${1}"
  git -C "${cache_folder}" config --get remote.origin.url | sed "s/^.*${GITLAB_URL}[:/]//;s/.git$//"
}
get_remote_url() {
  declare -r user="${1}"
  printf -- "https://oauth2:%s@%s/%s/%s.git" "${TOKEN}" "${GITLAB_URL}" "${REMOTE_NS}" "${user}"
}
get_cache_folder() {
  declare -r user="${1}"
  printf -- "%s/%s/%s" "${CACHE_FOLDER}" "${REMOTE_NS}" "${user}"
}
init_cache() {
  declare -r user="${1}"
  # shellcheck disable=SC2155
  declare -r cache_folder="$(get_cache_folder "${user}")"
  rm -rf "${cache_folder}"
  git_clone "$(get_remote_url "${user}")" "${cache_folder}"
}
sync_cache() {
  declare -r cache_folder="${1}"
  declare -r user_ns="${2}"
  declare -r user_branch="${3}"
  rsync -a --delete --exclude .git/ "${PROJECT_FOLDER}/" "${cache_folder}" \
    || exception "Unable to rsync files"
  [[ "${UPDATE_LINKS}" == 'true' ]] \
    && update_links "${user_ns}" "${cache_folder}/${README_FILE}" "${user_branch}"
}
update_cache() {
  declare -r user="${1}"
  declare -r cache_folder="${2}"
  [[ ! -d "${cache_folder}" ]] \
    && init_cache "${user}" "${cache_folder}" \
    && return
  # verify local remote
  declare actual_remote_ns
  actual_remote_ns="$(get_remote_namespace "${cache_folder}")" \
    || exit 1
  [[ "${actual_remote_ns}" != "${REMOTE_NS}/${user}" ]] \
    && exception 'Invalid user project remote origin url'
  git_pull "${cache_folder}" 'origin' "${SOURCE_BRANCH}:${SOURCE_BRANCH}"
}
update_links() {
  declare -r user_ns="${1}"
  declare -r readme_path="${2}"
  declare -r user_branch="${3}"
  sed -i "s~/${PROJECT_NS}/~/${user_ns}/~g" "${readme_path}"
  sed -i "s~/${PROJECT_BRANCH}/\(pipeline\|raw\|file\)~/${user_branch}/\1~g" "${readme_path}"
  sed -i "s~ref=${PROJECT_BRANCH}~ref=${user_branch}~g" "${readme_path}"
}
init_user_repo() {
  declare -r user="${1}"
  declare user_id=''
  [[ "${ASSIGN}" == "${NEVER}" ]] \
    || user_id="$(get_user_id "${user}")" \
    || exit 1
  [[ "${ASSIGN}" == "${ALWAYS}" && -z "${user_id}" ]] \
    && exception "User ${user} does not exist"
  [[ -n "${GROUP_ID}" ]] \
    || GROUP_ID="$(get_group_id "${REMOTE_NS}" 2>/dev/null)" \
    || GROUP_ID="$(create_ns "${REMOTE_NS}")" \
    || exit 1
  project_id="$(create_project "${GROUP_ID}" "${user}" "${user_id}")" \
    || exit 1
  add_developer "${project_id}" "${user_id}"
  [[ "${COPY_ISSUES}" == 'true' ]] \
    && copy_issues "${project_id}" "${user_id}"
  # shellcheck disable=SC2155
  declare -r cache_folder="$(get_cache_folder "${user}")"
  init_cache "${user}"
  git_commit "${cache_folder}" '--allow-empty' '-m "Initial commit"'
  git_push "${cache_folder}" '--all'
  declare user_branch
  user_branch="$(get_default_branch "${REMOTE_NS}/${user}")" \
    || exit 1
  remove_protected_branch "${project_id}" "${user_branch}"
  set_protected_branch "${project_id}" "${user_branch}" "${DEV_ACCESS_LEVEL}"
  set_protected_branch "${project_id}" "${SOURCE_BRANCH}" "${MAINTAINER_ACCESS_LEVEL}"
  sync_cache "${cache_folder}" "${REMOTE_NS}/${user}" "$user_branch"
  git_add_all "${cache_folder}"
  git_commit "${cache_folder}" '--allow-empty' '-m "Create assignment"'
  git_push "${cache_folder}" '--all'
  git_checkout "${cache_folder}" "-B${SOURCE_BRANCH}"
  git_push "${cache_folder}" '--all'
}
update_user_repo() {
  declare -r user="${1}"
  declare -r user_ns="${REMOTE_NS}/${user}"
  # shellcheck disable=SC2155
  declare -r cache_folder="$(get_cache_folder "${user}")"
  declare user_branch
  update_cache "${user}" "${cache_folder}"
  user_branch="$(get_default_branch "${user_ns}")" \
    || exit 1
  git_checkout "${cache_folder}" "${SOURCE_BRANCH}"
  sync_cache "${cache_folder}" "${user_ns}" "${user_branch}"
  git_status_empty "${cache_folder}" \
    && return
  git_add_all "${cache_folder}"
  git_commit "${cache_folder}" '-m "Update assignment"'
  git_push "${cache_folder}" '--all'
  declare project_id
  project_id="$(get_project_id "${user_ns}")" \
    || exit 1
  request_exists "${project_id}" \
    || create_request "${project_id}" "${user_branch}"
}
read_issues() {
  ISSUES="$(gitlab_api "api/v4/projects/${PROJECT_ID}/issues?labels=assignment")" \
    && ISSUES_COUNT="$(jq length <<< "${ISSUES}")" \
    || exit 1
}
copy_issues() {
  declare -r project_id="${1}"
  declare -r user_id="${2}"
  (( ISSUES_COUNT < 0 )) \
    && read_issues
  declare i issue
  for (( i=0; i < ISSUES_COUNT; i++ )); do
    issue="$(jq ".[${i}] | {title, description, due_date}" <<< "${ISSUES}")"
    [[ -n "${user_id}" ]] \
      && issue="$(jq --arg a "${user_id}" '. + {assignee_ids:[$a]}' <<< "${issue}")"
    gitlab_api "api/v4/projects/${project_id}/issues" "${issue}" >/dev/null
  done
}
validate_arguments() {
  msg_start 'Validating arguments'
  [[ -n "${REMOTE_NS}" ]] \
    || exception 'Missing argument REMOTE_NAMESPACE' 2
  [[ "${REMOTE_NS}" =~ ^[a-z0-9]{2,}(/[a-z0-9]{2,})*$ ]] \
    || exception 'Invalid argument REMOTE_NAMESPACE' 2
  [[ -d "${PROJECT_FOLDER}" ]] \
    || exception 'Project folder not found'
  [[ "${ASSIGN}" =~ ^(${ALWAYS}|${NEVER}|${AUTO})$ ]] \
    || exception 'Invalid option ASSIGN'
  [[ "${COPY_ISSUES}" == 'false' || -d "${PROJECT_FOLDER}/.git" ]] \
    || exception 'To copy issues, project must be a git repository'
  [[ "${UPDATE_LINKS}" == 'false' || -d "${PROJECT_FOLDER}/.git" ]] \
    || exception 'To update links, project must be a git repository'
  [[ "${UPDATE_LINKS}" == 'false' || -f "${PROJECT_FOLDER}/${README_FILE}" ]] \
    || exception 'Readme file not found'
  [[ ! -t 0 ]] \
    || exception 'Missing stdin' 2
  msg_end
}
read_project_info() {
  msg_start 'Getting project information'
  [[ "${COPY_ISSUES}" == 'false' && "${UPDATE_LINKS}" == 'false' ]] \
    && msg_end SKIPPED \
    && return
  PROJECT_NS="$(get_remote_namespace "${PROJECT_FOLDER}")" \
    && PROJECT_ID="$(get_project_id "${PROJECT_NS}")" \
    && PROJECT_BRANCH="$(git_current_branch "${PROJECT_FOLDER}")" \
    || exit 1
  msg_end
}
acquire_token() {
  [[ -s "${TOKEN_FILE}" ]] \
    || authorize
  TOKEN="$(cat "${TOKEN_FILE}")" \
    || exit 1
}
process_users() {
  declare username
  declare -i valid=0
  declare -i invalid=0
  # shellcheck disable=SC2013
  for username in $(cat <&3); do
    msg_start "Processing repository for ${username}"
    [[ ! "${username}" =~ ^[a-zA-Z0-9][a-z0-9_.-]*$ ]] \
      && msg_end INVALID \
      && invalid+=1 \
      && continue
    valid+=1
    [[ "${DRY_RUN}" == 'true' ]] \
      && msg_end SKIPPED \
      && continue
    project_exists "${REMOTE_NS}/${username}" \
      && update_user_repo "${username}" \
      && msg_end UPDATED \
      && continue
    init_user_repo "${username}"
    msg_end CREATED
  done
  (( valid != 0 || invalid != 0 )) \
    || exception 'Empty or invalid stdin' 2
  (( invalid == 0 )) \
    || exception "Invalid username occurred ${invalid} time(s)" 3
}

# global constants
# shellcheck disable=SC2155
declare -r SCRIPT_NAME="$(basename "${0}")"
declare -r TOKEN_FILE="${HOME}/.gitlab_access_token"
declare -r CACHE_FOLDER="${HOME}/.ca_distribute_cache"
declare -r README_FILE='README.md'
declare -r GITLAB_URL='gitlab.com'
declare -r SOURCE_BRANCH='source'
declare -r ALWAYS='always'
declare -r NEVER='never'
declare -r AUTO='auto'
declare -ri DEV_ACCESS_LEVEL=30
declare -ri MAINTAINER_ACCESS_LEVEL=40

# default variables
declare DIRECTORY='.'
declare DRY_RUN='false'
declare COPY_ISSUES='false'
declare UPDATE_LINKS='false'
declare ASSIGN="${AUTO}"
declare GROUP_ID=''
declare PROJECT_NS=''
declare PROJECT_ID=''
declare PROJECT_BRANCH=''
declare ISSUES=''
declare -i ISSUES_COUNT=-1

# USAGE
# shellcheck disable=SC2034
declare -r USAGE="DESCRIPTION
      This script reads USERNAMES from stdin using IFS. For each USERNAME it distributes files from PROJECT_FOLDER into REMOTE_NAMESPACE/USERNAME. Root namespace in REMOTE_NAMESPACE must exist, meaning e.g. 'umiami' in 'umiami/csc220/fall20'.

USAGE
      ${SCRIPT_NAME} [-adhiln] REMOTE_NAMESPACE

OPTIONS
      -a[WHEN], --assign[=WHEN]
              Assign ROLE (see below) to users for newly created projects and assign users to issues '${ALWAYS}', '${NEVER}', or '${AUTO}' (default).

      -d, --directory
              Specify the PROJECT_FOLDER (default PWD).

      -h, --help
              Display usage.

      -i, --process-issues
              Look for GitLab issues in the PROJECT_FOLDER. If PROJECT_FOLDER is a GitLab repository, copy issues marked with 'assignment' label into destination repositories.

      -l, --update-links
              Look for a ${README_FILE} if the PROJECT_FOLDER is a GitLab repository. Replace all occurrences of the assignment project's remote URL and its current branch with destination repository remote URL and its main branch.

      -n, --dry-run
              Only process arguments, options and stdin validation. Would not proceed with create or update user repositories.

EXIT CODES
       1      Other error.

       2      Invalid options or arguments including empty or missing stdin.

       3      Some (or all) invalid users.
"

# get options
declare OPT
OPT="$(getopt --name "${0}" --options 'a:d:hiln' \
  --longoptions 'assign:,directory:,help,process-issues,update-links,dry-run' \
  -- "$@")" \
  && eval set -- "${OPT}" \
  || exit 1

# process options
while (( $# > 0 )); do
  case "${1}" in
    -a|--assign) shift; ASSIGN="${1}"; shift ;;
    -d|--directory) shift; DIRECTORY="${1}"; shift ;;
    -h|--help) print_usage && exit 0 ;;
    -i|--process-issues) COPY_ISSUES='true'; shift ;;
    -l|--update-links) UPDATE_LINKS='true'; shift ;;
    -n|--dry-run) DRY_RUN='true'; shift ;;
    --) shift; break ;;
     *) break ;;
  esac
done

# validate and authorize
declare -r REMOTE_NS="${1}"
# shellcheck disable=SC2155
declare -r PROJECT_FOLDER="$(readlink -f "${DIRECTORY}")"

validate_arguments
# redir stdin
exec 3<&0
check_command git jq
acquire_token
read_project_info
process_users
