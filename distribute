#!/bin/bash

## functions
get_cache_folder() {
  printf -- "%s/%s" "${CACHE_FOLDER}" "${user_project_ns}"
}
init_cache() {
  # shellcheck disable=SC2155
  rm -rf "${user_cache_folder}"
  git_clone "$(get_remote_url)" "${user_cache_folder}"
}
sync_cache() {
  rsync -a --delete --exclude .git/ "${PROJECT_FOLDER}/" "${user_cache_folder}" \
    || exception "Unable to rsync files"
  declare -r user_readme_path="${user_cache_folder}/${README_FILE}"
  [[ "${UPDATE_LINKS}" == 'true' ]] \
    && update_links
}
update_cache() {
  [[ ! -d "${user_cache_folder}" ]] \
    && init_cache "${user_cache_folder}" \
    && return
  # verify local remote
  declare actual_remote_ns
  actual_remote_ns="$(get_remote_namespace "${user_cache_folder}")" \
    || exit 1
  [[ "${actual_remote_ns}" != "${user_project_ns}" ]] \
    && exception 'Invalid user project remote origin url'
  git_pull "${user_cache_folder}" 'origin' "${SOURCE_BRANCH}:${SOURCE_BRANCH}"
}
update_links() {
  sed -i "s~/${PROJECT_NS}/~/${user_project_ns}/~g" "${user_readme_path}"
  sed -i "s~/${PROJECT_BRANCH}/\(pipeline\|raw\|file\)~/${user_branch}/\1~g" "${user_readme_path}"
  sed -i "s~ref=${PROJECT_BRANCH}~ref=${user_branch}~g" "${user_readme_path}"
}
init_user_repo() {
  declare user_id=''
  [[ "${ASSIGN}" == "${NEVER}" ]] \
    || user_id="$(get_user_id)" \
    || exit 1
  [[ "${ASSIGN}" == "${ALWAYS}" && -z "${user_id}" ]] \
    && exception "User ${user_name} does not exist"
  [[ -n "${GROUP_ID}" ]] \
    || GROUP_ID="$(get_group_id "${REMOTE_NS}" 2>/dev/null)" \
    || GROUP_ID="$(create_ns "${REMOTE_NS}")" \
    || exit 1
  project_id="$(create_user_project)" \
    || exit 1
  add_developer
  [[ "${COPY_ISSUES}" == 'true' ]] \
    && copy_issues
  init_cache
  git_commit "${user_cache_folder}" '--allow-empty' '-m "Initial commit"'
  git_push "${user_cache_folder}" '--all'
  declare user_branch
  user_branch="$(get_default_branch)" \
    || exit 1
  remove_protected_branch
  set_protected_branch "${user_branch}" "${DEV_ACCESS_LEVEL}"
  set_protected_branch "${SOURCE_BRANCH}" "${MAINTAINER_ACCESS_LEVEL}"
  sync_cache
  git_add_all "${user_cache_folder}"
  git_commit "${user_cache_folder}" '--allow-empty' '-m "Create assignment"'
  git_push "${user_cache_folder}" '--all'
  git_checkout "${user_cache_folder}" "-B${SOURCE_BRANCH}"
  git_push "${user_cache_folder}" '--all'
}
update_user_repo() {
  declare user_branch
  update_cache
  user_branch="$(get_default_branch)" \
    || exit 1
  git_checkout "${user_cache_folder}" "${SOURCE_BRANCH}"
  sync_cache
  git_status_empty "${user_cache_folder}" \
    && return
  git_add_all "${user_cache_folder}"
  git_commit "${user_cache_folder}" '-m "Update assignment"'
  git_push "${user_cache_folder}" '--all'
  declare project_id
  project_id="$(get_project_id "${user_project_ns}")" \
    || exit 1
  request_exists \
    || create_request
}
read_issues() {
  ISSUES="$(gitlab_api "api/v4/projects/${PROJECT_ID}/issues?labels=assignment")" \
    && ISSUES_COUNT="$(jq length <<< "${ISSUES}")" \
    || exit 1
}
copy_issues() {
  (( ISSUES_COUNT < 0 )) \
    && read_issues
  declare i issue
  for (( i=0; i < ISSUES_COUNT; i++ )); do
    issue="$(jq ".[${i}] | {title, description, due_date}" <<< "${ISSUES}")"
    [[ -n "${user_id}" ]] \
      && issue="$(jq --arg a "${user_id}" '. + {assignee_ids:[$a]}' <<< "${issue}")"
    gitlab_api "api/v4/projects/${project_id}/issues" "${issue}" >/dev/null
  done
}
validate_arguments() {
  msg_start 'Validating arguments'
  [[ -n "${REMOTE_NS}" ]] \
    || exception 'Missing argument REMOTE_NAMESPACE' 2
  [[ "${REMOTE_NS}" =~ ^[a-z0-9]{2,}(/[a-z0-9]{2,})*$ ]] \
    || exception 'Invalid REMOTE_NAMESPACE dirname' 2
  [[ "${USER_PROJECT_PREFIX}" =~ ^[a-z0-9]{2,}$ ]] \
    || exception 'Invalid REMOTE_NAMESPACE basename' 2
  [[ -d "${PROJECT_FOLDER}" ]] \
    || exception 'Project folder not found'
  [[ "${ASSIGN}" =~ ^(${ALWAYS}|${NEVER}|${AUTO})$ ]] \
    || exception 'Invalid option ASSIGN'
  [[ "${COPY_ISSUES}" == 'false' || -d "${PROJECT_FOLDER}/.git" ]] \
    || exception 'To copy issues, project must be a git repository'
  [[ "${UPDATE_LINKS}" == 'false' || -d "${PROJECT_FOLDER}/.git" ]] \
    || exception 'To update links, project must be a git repository'
  [[ "${UPDATE_LINKS}" == 'false' || -f "${PROJECT_FOLDER}/${README_FILE}" ]] \
    || exception 'Readme file not found'
  [[ ! -t 0 ]] \
    || exception 'Missing stdin' 2
  msg_end
}
read_project_info() {
  msg_start 'Getting project information'
  [[ "${COPY_ISSUES}" == 'false' && "${UPDATE_LINKS}" == 'false' ]] \
    && msg_end SKIPPED \
    && return
  PROJECT_NS="$(get_remote_namespace "${PROJECT_FOLDER}")" \
    && PROJECT_ID="$(get_project_id "${PROJECT_NS}")" \
    && PROJECT_BRANCH="$(git_current_branch "${PROJECT_FOLDER}")" \
    || exit 1
  msg_end
}
acquire_token() {
  [[ -s "${TOKEN_FILE}" ]] \
    || authorize
  # shellcheck disable=SC2034
  TOKEN="$(cat "${TOKEN_FILE}")" \
    || exit 1
}
process_users() {
  declare user_name
  declare user_project_name
  declare user_project_ns
  declare user_cache_folder
  declare -i valid=0
  declare -i invalid=0
  # shellcheck disable=SC2013
  for user_name in $(cat <&3); do
    msg_start "Processing repository for ${user_name}"
    [[ ! "${user_name}" =~ ^[a-zA-Z0-9][a-z0-9_.-]*$ ]] \
      && msg_end INVALID \
      && invalid+=1 \
      && continue
    valid+=1
    [[ "${DRY_RUN}" == 'true' ]] \
      && msg_end SKIPPED \
      && continue
    user_project_name="${USER_PROJECT_PREFIX}-${user_name}"
    user_project_ns="${REMOTE_NS}/${user_project_name}"
    user_cache_folder="$(get_cache_folder)"
    project_exists \
      && update_user_repo \
      && msg_end UPDATED \
      && continue
    init_user_repo
    msg_end CREATED
  done
  (( valid != 0 || invalid != 0 )) \
    || exception 'Empty or invalid stdin' 2
  (( invalid == 0 )) \
    || exception "Invalid username occurred ${invalid} time(s)" 3
}

# global constants
# shellcheck disable=SC2155
declare -r SCRIPT_NAME="$(basename "${0}")"
declare -r TOKEN_FILE="${HOME}/.gitlab_access_token"
declare -r CACHE_FOLDER="${HOME}/.ca_distribute_cache"
declare -r README_FILE='README.md'
declare -r SOURCE_BRANCH='source'
declare -r ALWAYS='always'
declare -r NEVER='never'
declare -r AUTO='auto'
declare -ri DEV_ACCESS_LEVEL=30
declare -ri MAINTAINER_ACCESS_LEVEL=40

# default variables
declare DIRECTORY='.'
declare DRY_RUN='false'
declare COPY_ISSUES='false'
declare UPDATE_LINKS='false'
declare ASSIGN="${AUTO}"
declare GROUP_ID=''
declare PROJECT_NS=''
declare PROJECT_ID=''
declare PROJECT_BRANCH=''
declare ISSUES=''
declare -i ISSUES_COUNT=-1

# USAGE
declare USAGE="DESCRIPTION
      This script reads USERNAMES from stdin using IFS. For each USERNAME it distributes files from PROJECT_FOLDER into REMOTE_NAMESPACE-USERNAME. Root namespace in REMOTE_NAMESPACE must exist, meaning e.g. 'umiami' in 'umiami/csc220/fall20'.

USAGE
      ${SCRIPT_NAME} [-adhiln] REMOTE_NAMESPACE

OPTIONS
      -a[WHEN], --assign[=WHEN]
              Assign ROLE (see below) to users for newly created projects and assign users to issues '${ALWAYS}', '${NEVER}', or '${AUTO}' (default).

      -d, --directory
              Specify the PROJECT_FOLDER (default PWD).

      -h, --help
              Display usage.

      -i, --process-issues
              Look for GitLab issues in the PROJECT_FOLDER. If PROJECT_FOLDER is a GitLab repository, copy issues marked with 'assignment' label into destination repositories.

      -l, --update-links
              Look for a ${README_FILE} if the PROJECT_FOLDER is a GitLab repository. Replace all occurrences of the assignment project's remote URL and its current branch with destination repository remote URL and its main branch.

      -n, --dry-run
              Only process arguments, options and stdin validation. Would not proceed with create or update user repositories.

EXIT CODES
       1      Other error.

       2      Invalid options or arguments including empty or missing stdin.

       3      Some (or all) invalid users.
"

# get options
declare OPT
OPT="$(getopt --name "${0}" --options 'a:d:hiln' \
  --longoptions 'assign:,directory:,help,process-issues,update-links,dry-run' \
  -- "$@")" \
  && eval set -- "${OPT}" \
  || exit 1

# process options
while (( $# > 0 )); do
  case "${1}" in
    -a|--assign) shift; ASSIGN="${1}"; shift ;;
    -d|--directory) shift; DIRECTORY="${1}"; shift ;;
    -h|--help) print_usage "${USAGE}" && exit 0 ;;
    -i|--process-issues) COPY_ISSUES='true'; shift ;;
    -l|--update-links) UPDATE_LINKS='true'; shift ;;
    -n|--dry-run) DRY_RUN='true'; shift ;;
    --) shift; break ;;
     *) break ;;
  esac
done

# validate and authorize
# shellcheck disable=SC2155
declare -r REMOTE_NS="$(dirname "${1}")"
# shellcheck disable=SC2155
declare -r USER_PROJECT_PREFIX="$(basename "${1}")"
# shellcheck disable=SC2155
declare -r PROJECT_FOLDER="$(readlink -f "${DIRECTORY}")"

validate_arguments
# redir stdin
exec 3<&0
check_command git jq
acquire_token
read_project_info
process_users
