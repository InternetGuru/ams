#!/usr/bin/env bash

declare MSG_OPENED='false'

clear_stdin() {
  while read -r -t 0; do read -r; done
}
msg_start() {
  [[ "${MSG_OPENED}" == 'true' ]] \
    && exception 'Message already started'
  MSG_OPENED='true'
  printf -- '%s ... ' "$@" >&2
}
msg_end() {
  declare -r close_message=${1:-DONE}
  [[ "${MSG_OPENED}" = 'false' ]] \
    && exception 'Message not started'
  MSG_OPENED='false'
  printf -- '[ %s ]\n' "${close_message}" >&2
}
confirm() {
  printf -- '%s [YES/No] ' "${1:-'Are you sure?'}" >&2
  clear_stdin
  read -r
  [[ "${REPLY}" =~ ^[Yy]([Ee][Ss])?$ || -z "${REPLY}" ]] \
    && return 0
  [[ "${REPLY}" =~ ^[Nn][Oo]?$ ]] \
    && return 1
  confirm 'Type'
}
prompt() {
  declare -r message="${1:-Enter value}"
  printf -- '%s: ' "${message}" >&2
  clear_stdin
  read -r
  [[ -n "${REPLY}" ]] \
    && return 0
  prompt "${message}"
}
exception() {
  declare -r message="${1:-Unknown exception}"
  declare -ri code=${2:-1}
  (( code == 1 )) \
    && printf -- '%s in %s() [ #%d ]\n' "${message}" "${FUNCNAME[1]}" "${code}" >&2 \
    || printf -- '%s [ #%d ]\n' "${message}" "${code}" >&2
  exit "${code}"
}
warning() {
  declare -r message="${1:-Unknown warning}"
  printf -- '%s\n' "${message}" >&2
}
check_x() {
  [[ -x "${1}" ]] \
    || chmod +x "${1}"
}
print_usage() {
  declare out
  declare cmd="${CMD}"
  [[ -n "${CMD}" ]] \
    && cmd="-${cmd}"
  # shellcheck disable=SC2155
  declare usage="$(get_md_section "## SYNOPSIS" < "${DIR}/documentation/${SCRIPT}${cmd}.md")"
  [[ -n "${usage}" ]] \
    && out="usage: ${usage}"
  # shellcheck disable=SC2155
  declare commands="$(get_md_section "## COMMANDS" < "${DIR}/documentation/${SCRIPT}${cmd}.md")"
  [[ -n "${commands}" ]] \
    && out="${out}"$'\n'"${commands}"
  # shellcheck disable=SC2155
  declare options="$(get_md_section "## OPTIONS" < "${DIR}/documentation/${SCRIPT}${cmd}.md")"
  # shellcheck disable=SC2001
  [[ -n "${options}" ]] \
    && out="${out}"$'\n'"$(sed 's/^/    /g' <<< "${options}")"
  fmt -w "$(tput cols)" <<< "${out}"
}
check_command() {
  for cmd in "${@}"; do
    command -v "${cmd}" >/dev/null 2>&1 \
      || exception "Command ${cmd} not found"
  done
}
get_md_section() {
  declare -r section="${1}"
  awk -v section="${section}" '
    BEGIN {
      out = 0
    }
    /^##/ {
      if ($0 == section) {
        out = 1; next
      }
      out = 0
    }
    {
      if (out == 1) {
        print
      }
    }' \
    | sed 's/`//g'
}
process_user_scripts() {
  declare -r type="${1:-}"
  [[ -z "${type}" ]] \
    && exception "Missing type argument in process_user_scripts"
  [[ -z "${ACADEMY_LANG}" ]] \
    && warning "Undefined ACADEMY_LANG variable. Skipping.." \
    && return 0
  [[ ! -f "${DIR}/${type}_${ACADEMY_LANG}" ]] \
    && exception "Missing ${type} script '${type}_${ACADEMY_LANG}' for selected language."
  declare -r RESULTS="${WORKING_DIR}/.results"
  declare -r ACADEMY_CACHE="${HOME}/.academy"
  mkdir -p "${RESULTS}"
  mkdir -p "${ACADEMY_CACHE}"
  declare -A CHANGED_FILES
  declare editable_files
  # shellcheck disable=SC2086
  # shellcheck disable=SC2164
  editable_files="$(cd "${WORKING_DIR}"; ls -d -- ${ACADEMY_EDITABLE})"
  # shellcheck disable=SC2034
  [[ -n "$editable_files" ]] \
    && mapfile -t CHANGED_FILES < <(
      git -C "${WORKING_DIR}" diff HEAD..HEAD~1 --name-only 2>/dev/null \
        | grep -Fx "${editable_files}"
    )
  # shellcheck disable=SC1090
  [[ -f "${DIR}/pre-${type}_${ACADEMY_LANG}" ]] \
    && source "${DIR}/pre-${type}_${ACADEMY_LANG}"
  # shellcheck disable=SC1090
  source "${DIR}/${type}_${ACADEMY_LANG}"
  # shellcheck disable=SC1090
  [[ -f "${DIR}/post-${type}_${ACADEMY_LANG}" ]] \
    && source "${DIR}/post-${type}_${ACADEMY_LANG}"
  return 0
}
run_io_tests() {
  "${DIR}/iotest" "${IOTEST_FOLDER}" "${1}" | tee "${IOTEST_LOG}"
  declare summary passed count
  summary="$(grep 'Summary:' < "${IOTEST_LOG}" | cut -d ' ' -f2-)"
  count="$(cut -d',' -f1 <<< "${summary}" | cut -d' ' -f2)"
  passed="$(cut -d',' -f3 <<< "${summary}" | cut -d' ' -f3)"
  declare test_color='success'
  [[ ${passed} -lt ${count} ]] \
    && test_color='critical'
  generate_badge 'IO Tests' "${passed}/${count}" "${test_color}"
}
