stages:
 - build
 - manage
 - run
 - post-process

variables:
  ACADEMY_DEFAULT_DOCKER_IMAGE: "internetguru/academy:latest"
  ACADEMY_DOCKER_IMAGE: ${ACADEMY_DEFAULT_DOCKER_IMAGE}
  ACADEMY_CACHE: ".academy-cache"

cache:
  key: academy-cache
  paths:
    - $ACADEMY_CACHE

.before_script_global: &global_init |
  # fix TERM
  export TERM=xterm
  # checkout to current branch
  git checkout -B "${CI_COMMIT_REF_NAME}" "${CI_COMMIT_SHA}"
  # set git user
  git config --global user.email "${GITLAB_USER_EMAIL}"
  git config --global user.name "Runner = ${CI_RUNNER_DESCRIPTION}"
  mkdir -p ${ACADEMY_CACHE}
  export ACADEMY_DIR="$(mktemp -d)"
  revision=$(grep -oP -m1 "[^/]+(?=/gitlab-stages)" .gitlab-ci.yml)
  git clone --single-branch --branch ${revision} https://github.com/InternetGuru/academy ${ACADEMY_DIR}
  # e.g. /umiami/george/csc220
  declare -r namespace="${CI_PROJECT_NAMESPACE}"
  declare -r project_name="$(basename "${PWD}")"
  declare -r user_namespace="${namespace}/${CI_COMMIT_REF_NAME}/${project_name}"
  # simplify project remote url
  git remote set-url --push origin "${namespace}/${project_name}.git"
  # set permissions
  declare ACADEMY=${ACADEMY_DIR}/academy
  chmod +x ${ACADEMY_DIR}/*
  declare DASHBOARD_PROJECT_NAME="${project_name}"


.before_script_token: &validate_token |
  # prepare acccess token for the distribution script
  if [[ -z "${ACADEMY_GITLAB_ACCESS_TOKEN}" ]]; then
    echo "Undefined variable {ACADEMY_GITLAB_ACCESS_TOKEN}"
    echo "Refer to README and make sure the current branch is protected."
    exit 1
  fi

.get_users: &get_users |
  # do not distribute ACADEMY_ASSIGN file
  if [[ -f "ACADEMY_ASSIGN" ]]; then
    mv "ACADEMY_ASSIGN" ..
    # commit move to keep git status empty (do not push)
    git commit -m "move users file" -- "ACADEMY_ASSIGN"
  fi
  # do not distribute ACADEMY_ALLOW file
  if [[ -f "ACADEMY_ALLOW" ]]; then
    mv "ACADEMY_ALLOW" ..
    # commit move to keep git status empty (do not push)
    git commit -m "move allow file" -- "ACADEMY_ALLOW"
  fi
  declare users
  if [[ -n "${ACADEMY_ASSIGN}" ]]; then
    users="${ACADEMY_ASSIGN}"
  elif [[ -f '../ACADEMY_ASSIGN' ]]; then
    users="$(<../ACADEMY_ASSIGN)"
  else
    users="${GITLAB_USER_NAME}"
  fi
  users="$(tr ',' ' ' <<< "${users}")"

collect:
  image: ${ACADEMY_DEFAULT_DOCKER_IMAGE}
  stage: manage
  tags:
    - docker
  before_script:
    - *validate_token
    - *global_init
  script:
    # set token file (will be deprecated)
    - echo "${ACADEMY_GITLAB_ACCESS_TOKEN}" > ${HOME}/.ACADEMY_GITLAB_ACCESS_TOKEN
    # checkout to ACADEMY_SOLUTION branch
    - |
        if [[ -z "${ACADEMY_SOLUTION}" ]]; then
          ACADEMY_SOLUTION="${CI_DEFAULT_BRANCH}"
        fi
        git fetch --all
        git checkout "${ACADEMY_SOLUTION}"
    # run collect for given or all branches
    - mkdir -p '.collect'
    - *get_users
    - |
        ${ACADEMY} collect \
        --namespace "${user_namespace}" \
        --output-dir '.collect' \
        <<< "${users}" \
        | tee 'summary.txt'
    # output variables and summary
    #- mv 'summary.txt' '.collect/'
    - |
      echo '#######################'
      echo "ACADEMY_DEADLINE: '${ACADEMY_DEADLINE}'"
      echo "ACADEMY_EDITABLE: '${ACADEMY_EDITABLE}'"
      echo "ACADEMY_SOLUTION: '${ACADEMY_SOLUTION}'"
      echo "summary.txt: ${CI_PROJECT_URL}/-/jobs/${CI_JOB_ID}/artifacts/raw/.collect/summary.txt"
      echo '#######################'
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: always
    - if: $CI_COMMIT_BRANCH == "source"
      when: never
    - exists:
      - "ACADEMY_ASSIGN"
      when: manual
    - when: never
  artifacts:
    paths:
      - .collect/
    expire_in: 1 year
  allow_failure: true

distribute:
  image: ${ACADEMY_DEFAULT_DOCKER_IMAGE}
  stage: manage
  tags:
    - docker
  before_script:
    - *validate_token
    - *global_init
  script:
    # set token file (will be deprecated)
    - echo "${ACADEMY_GITLAB_ACCESS_TOKEN}" > ${HOME}/.ACADEMY_GITLAB_ACCESS_TOKEN
    - *get_users
    # distribute current project among all users
    - |
        ${ACADEMY} distribute --update-links --namespace "${user_namespace}" \
        --process-issues "${ACADEMY_ISSUES:-${CI_COMMIT_REF_NAME}}" \
        <<< "${users}"
  rules:
    - if: $CI_COMMIT_BRANCH == "source"
      when: never
    - if: '$ACADEMY_DISTRIBUTE == "always"'
      when: always
    - exists:
      - "ACADEMY_ASSIGN"
      when: manual
    - when: never
  allow_failure: true

measure:
  image: ${ACADEMY_DEFAULT_DOCKER_IMAGE}
  stage: manage
  tags:
    - docker
  before_script:
    - *validate_token
    - *global_init
  script:
    - |
        if [[ -z "${ACADEMY_MOSSURL}" ]]; then
          echo "Missing ACADEMY_MOSSURL"
          exit 1
        fi
    # set token file (will be deprecated)
    - echo "${ACADEMY_GITLAB_ACCESS_TOKEN}" > ${HOME}/.ACADEMY_GITLAB_ACCESS_TOKEN
    # download moss script
    - curl -o /usr/local/bin/moss "${ACADEMY_MOSSURL}"
    - chmod +x /usr/local/bin/moss
    - export PATH="${PATH}:/usr/local/bin/"
    # create output directory
    - declare -r measure_output=".measure/${project_name}"
    - mkdir -p "${measure_output}"
    # copy files from ACADEMY_SOLUTION branch to measure
    - |
        if [[ -z "${ACADEMY_SOLUTION}" ]]; then
          ACADEMY_SOLUTION="${CI_DEFAULT_BRANCH}"
        fi
        git fetch --all
        git --work-tree="${measure_output}" checkout -f "origin/${ACADEMY_SOLUTION}" -- .
    # run measure for given or all branches
    - *get_users
    - |
      ${ACADEMY} measure --output-dir "${measure_output}" \
      --namespace "${user_namespace}"
      <<< "${users}"
  rules:
    - if: $CI_COMMIT_BRANCH == "source"
      when: never
    - exists:
      - "ACADEMY_ASSIGN"
      when: manual
    - when: never
  allow_failure: true

execute:
  image: ${ACADEMY_DOCKER_IMAGE}
  stage: run
  tags:
    - docker
  before_script:
    - *global_init
    - |
      # skip initial commits
      if [[ $(git rev-list --all --count) -le 1 ]]; then
        exit 0
      fi
      # do not evaluate ACADEMY_ASSIGN changes only
      if [[ "$(git diff HEAD..HEAD~1 --name-only)" == "ACADEMY_ASSIGN" ]]; then
        echo "Project execution stoped due to changes in ACADEMY_ASSIGN only"
        exit 1
      fi
  script:
    - echo '%% job start execute %%'
    - ${ACADEMY} execute
    - echo '%% job end execute %%'
  artifacts:
    paths:
      - .results/
    expire_in: 1 year
  rules:
    - if: $CI_COMMIT_BRANCH == "source"
      when: never
    - if: '$ACADEMY_EXECUTE == "always"'
      when: always
    - when: manual
  allow_failure: true

evaluate:
  image: ${ACADEMY_DOCKER_IMAGE}
  stage: run
  tags:
    - docker
  before_script:
    - *global_init
    - |
      # skip initial commits
      if [[ $(git rev-list --all --count) -le 1 ]]; then
        exit 0
      fi
      # do not evaluate ACADEMY_ASSIGN changes only
      if [[ "$(git diff HEAD..HEAD~1 --name-only)" == "ACADEMY_ASSIGN" ]]; then
        echo "Project evaluation stoped due to changes in ACADEMY_ASSIGN only"
        exit 1
      fi
  script:
    - echo '%% job start evaluate %%'
    - ${ACADEMY} evaluate
    - echo '%% job end evaluate %%'
  artifacts:
    paths:
      - .results/
    expire_in: 1 year
  rules:
    - if: $CI_COMMIT_BRANCH == "source"
      when: never
    - if: '$ACADEMY_EVALUATE == "always"'
      when: always
    - when: manual
  allow_failure: true

meta:
  image: ${ACADEMY_DEFAULT_DOCKER_IMAGE}
  stage: post-process
  tags:
    - docker
  before_script:
    - *global_init
  script:
    - |
      echo "${ACADEMY_DASHBOARD}/${namespace}/${DASHBOARD_PROJECT_NAME}"
      # clear dashboard cache
      curl "${ACADEMY_DASHBOARD}/${namespace}/${DASHBOARD_PROJECT_NAME}" \
        -I -H "Cache-Control: no-cache" -H "Accept: application/json"
      # create age badge
      mkdir -p .results
      source "${ACADEMY_DIR}/badges"
      WORKING_DIR='.'
      badge_generate 'Age' "$(date +"%Y-%m-%dT%H:%M:%S%z")" 'blue'
      badge_generate 'Updates' 'n/a'
      badge_generate 'Status' 'n/a'
    - |
      for badge in .results/badge-*.svg; do
        [[ "${badge}" =~ ".results/badge-"([^-]+)-(.*)".svg" ]]
        job="${BASH_REMATCH[1]}"
        badge_name="${BASH_REMATCH[2]}"
        printf -- '![%s](%s/builds/artifacts/%s/raw/%s?job=%s)\n' \
          "${badge_name}" "${CI_PROJECT_URL}" "${CI_COMMIT_REF_NAME}" "${badge}" "${job}"
      done
  rules:
    - if: $CI_COMMIT_BRANCH == "source"
      when: never
    - when: always
  artifacts:
    paths:
      - .results/
    expire_in: 1 year
